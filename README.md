# CPP11-ThreadPool

## 1. 项目名称
**C++11 轻量级线程池**

基于 C++11 实现的高可用线程池，支持动态扩缩容、异常任务安全处理、多线程并发调度，适配 Linux/Windows 平台。

## 2. 项目介绍
该线程池核心解决「多线程任务调度的资源复用与安全问题」，相比原生 pthread 直接创建线程，具备以下优势：

- **线程复用**：避免频繁创建/销毁线程的系统开销。
- **动态扩缩容**：根据任务队列长度、忙线程数自动调整存活线程数。
- **异常安全**：单个任务抛异常不影响线程池整体运行，状态统计精准。
- **内存安全**：基于智能指针 + RAII 自动管理任务参数/线程资源，无内存泄漏。
- **易用性**：通用任务接口支持任意类型任务投递，配置化初始化（核心线程数/最大线程数/队列容量）。

## 3. 核心功能

| 功能特性 | 描述 |
|---------|------|
| 动态扩缩容 | 自动扩容（最多批量创建2个线程），线程空闲时自动缩容（保留核心线程） |
| 任务队列限流 | 大容量任务队列，满队列时阻塞添加任务，避免内存溢出 |
| 异常任务处理 | 单个任务异常不影响整体，保证忙线程数/存活线程数精准回滚，线程池不崩溃 |
| 线程池安全关闭 | 禁止新任务，唤醒所有阻塞线程，优雅回收所有线程资源 |
| 多线程并发添加任务 | 支持多线程同时投递任务，任务队列线程安全 |
| 状态监控 | 实时统计线程数、忙线程数、任务队列长度，便于调试和监控 |

## 4. 技术栈

### 语言与标准
- **C++11**：原子变量、条件变量、智能指针、Lambda、移动语义

### 核心组件
- `std::atomic`：线程安全状态管理
- `std::condition_variable`：线程阻塞/唤醒机制
- `std::mutex`：互斥锁保证临界区安全
- `std::unique_ptr`：智能指针自动内存管理

### 设计模式
- **RAII**：资源获取即初始化，自动管理资源生命周期
- **生产者-消费者**：任务队列调度模型

### 测试策略
- 断言校验：确保关键逻辑正确性
- 多场景测试：队列满/并发添加/异常任务/缩容/关闭

## 5. 快速开始

### 编译与运行

#### Linux
```bash
g++ -std=c++11 main.cpp -o thread_pool -lpthread
./thread_pool
```

#### Windows
```cmd
g++ -std=c++11 main.cpp -o thread_pool
thread_pool.exe
```

### 基本使用示例

```cpp
#include "ThreadPool.hpp"

// 自定义任务函数
void customTask(void* arg) {
    int num = *(static_cast<int*>(arg));
    // 用户需要的业务逻辑...
}

int main() {
    // 初始化线程池：核心线程2，最大线程8，队列容量20
    ThreadPool pool(2, 8, 20);
    
    // 添加任务
    for (int i = 0; i < 100; ++i) {
        int* taskNum = new int(1 + i);
        pool.addTask(customTask, taskNum);
    }
    
    // 手动关闭线程池(可选)
    std::this_thread::sleep_for(std::chrono::seconds(30)); // 运行30秒再手动关闭
    pool.shutdownPool();

    return 0;
}
```

## 6. 测试用例说明

项目内置6类测试场景，覆盖线程池核心能力：

1. **初始化校验**：验证核心线程数、队列初始状态
2. **队列满测试**：连续添加任务至队列满，验证阻塞/拒绝逻辑
3. **并发添加任务**：5个线程并发添加50个任务，验证扩容逻辑
4. **缩容测试**：任务执行完毕后，验证自动缩容至核心线程数
5. **关闭测试**：关闭线程池后添加任务，验证拒绝逻辑
6. **异常任务测试**：单独测试异常任务执行，验证线程池稳定性

**注意**：异常任务测试与其他测试一起运行会相互干扰，因此使用`#if 0`/`#endif`控制测试用例，将0改为1即可启用（只能有一个main函数）。

## 7. 核心设计细节

### 7.1 任务结构体设计

通用任务结构体支持任意类型任务投递，通过`std::unique_ptr+自定义删除器`管理参数，避免`delete void*`的未定义行为：

```cpp
struct Task {
    using funcType = void(*)(void*);
    funcType function;                       // 任务函数指针
    std::unique_ptr<void, void(*)(void*)> arg; // 通用参数+自定义释放器
};
```

### 7.2 WorkerStatus结构体设计

将`std::thread`对象与线程状态(活跃/退出)封装进`WorkerStatus`结构体，当线程被要求退出(缩容)或是异常退出时，管理者可以基于这个标志判断是否清理(join)掉这个线程，以此保证无用线程不占用资源：

```cpp
struct WorkerStatus {
    std::thread thread;               // 工作线程对象（C++11线程句柄）
    std::atomic<bool> isFinished;     // 线程是否已完成（退出）：原子变量保证多线程读写安全
    std::thread::id tid;              // 缓存线程ID：避免线程退出后get_id()失效
    // ...
};
```

### 7.3 管理者清理细节

管理者线程负责定期清理已完成的工作线程，确保资源及时释放：

```cpp
void managerFunc() {
    // ...
    std::lock_guard<std::mutex> lock(poolLock);  // 加锁保护线程列表
    auto it = workers.begin();
    
    while (it != workers.end()) {
        // 仅清理已完成的线程
        if (it->isFinished) {
            std::thread::id tid = it->tid;
            
            // 1. 回收线程系统资源：必须join（避免僵尸线程）
            if (it->thread.joinable()) {
                it->thread.join();
                std::cout << "[清理] 回收已完成线程，tid=" << tid << std::endl;
            }
            
            // 2. 删除线程状态对象：释放容器内存
            it = workers.erase(it);
            cleanCount++;
            std::cout << "[清理] 删除线程状态对象，tid=" << tid << std::endl;
        } else {
            ++it;
        }
    }
    // ...
}
```

### 7.4 异常安全设计

1. **RAII管理忙线程数**：工作线程执行任务时通过RAII自动管理忙线程数，无论正常/异常执行，析构时必回滚
2. **异常捕获兜底**：使用`try-catch`捕获所有异常，异常退出时更新存活线程数，保证状态精准
3. **安全关闭机制**：线程池关闭时唤醒所有阻塞线程，避免永久阻塞

### 7.5 动态扩缩容逻辑

#### 扩容条件
- 任务队列长度 > 存活线程数 且 存活线程数 < 最大线程数
- 或 当前存活线程数 < 核心线程数（确保核心线程数）

#### 缩容条件
- 忙线程数 * 2 < 存活线程数 且 存活线程数 > 核心线程数

#### 批量操作
- 每次扩容/缩容最多2个线程，减少频繁操作开销

## 8. 项目演进历程

这是我在这个项目从简单到复杂逐步演进的学习过程：

1. **基础模型**：烂大街的基于生产者-消费者模型的C语言线程池
2. **面向对象封装**：用C++面向对象思想封装线程池
3. **智能指针引入**：使用智能指针管理任务参数内存
4. **任务结构体封装**：实现`std::move`语义和左值/右值概念
5. **C++11线程库**：用`std::thread`替换`pthread`库
6. **同步原语升级**：引入`condition_variable`、`mutex`等C++11同步原语
7. **原子变量**：使用`atomic`原子变量保证多线程安全
8. **线程清理机制**：实现WorkerStatus结构体和管理者线程清除功能
9. **异常处理**：添加全面的异常捕获和处理机制
10. **RAII优化**：引入RAII管理busyNum，确保状态一致性
11. **全面测试**：多场景测试确保功能稳定
12. **项目管理**：学习GitHub使用和工作流

